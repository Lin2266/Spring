JPA(Java Persistence API)java持久性API

全稱是Java Persistence API是一個標準規範及接口(API)來實現ORM(object-relational mapping)框架，JPA通過
註解(annotation) [如：@Entity、@Table、@Column等註解] 或XML描述物件－關係表的對映關係，並將執行期的實
體物件持久化到資料庫中。
---------------------------------------------------------------------------------------------------------------------------
JPA的出現有兩個原因：
1，簡化現有Java EE和Java SE應用的物件持久化的開發工作；
2，Sun希望整合對ORM技術，實現持久化領域的統一。
JPA通過JDK 5.0註解描述對象－關係表的映射關係，並將運行期的實體對象持久化到數據庫中。
JPA不是一種框架，而是一個標準規範。而要使用JPA的功能就需要Provider來配合，而Provider就是各種ORM框架。

在JPA底下其實有各種ORM框的選擇，可按項目的情況選擇合適的框(例如:hibernate)。

JPA已經被廣泛採用，已經成為O/R持久化企業標準。
JPA是獨立於SQL ，基於JDBC之上的抽象層。所有類和註解都在javax.persistence包中。

-------------------------------------------------------------------------------------------------------------------------
JPA的優勢

標準化
JPA 是 JCP 組織發佈的 Java EE 標準之一，因此任何聲稱符合 JPA 標準的框架都遵循同樣的架構，提供相同的訪問API
，這保證了基於JPA開發的企業應用能夠經過少量的修改就能夠在不同的JPA框架下運行。

容器級特性的支持
JPA框架中支持大數據集、事務、併發等容器級事務，這使得 JPA 超越了簡單持久化框架的局限，在企業應用發揮更大的作用。

簡單方便
JPA的主要目標之一就是提供更加簡單的編程模型：在JPA框架下創建實體和創建Java 類一樣簡單，沒有任何限制，只需要使用 
javax.persistence.Entity進行註釋，JPA的框架和接口也都非常簡單，沒有太多特別的規則和設計模式的要求，開發者可以很
容易的掌握。JPA基於非侵入式原則設計，因此可以很容易的和其它框架或者容器集成。

查詢能力
JPA的查詢語言是面向對象而非面向數據庫的，它以面向對象的自然語法構造查詢語句，可以看成是Hibernate HQL的等價物。
JPA定義了獨特的JPQL（Java Persistence Query Language），JPQL是EJB QL的一種擴展，它是針對實體的一種查詢語言，
操作對象是實體，而不是關係數據庫的表，而且能夠支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能夠
提供的高級查詢特性，甚至還能夠支持子查詢。

高級特性
JPA 中能夠支持面向對象的高級特性，如類之間的繼承、多態和類之間的複雜關係，這樣的支持能夠讓開發者最大限度的使用
面向對象的模型設計企業應用，而不需要自行處理這些特性在關係數據庫的持久化。
-------------------------------------------------------------------------------------------------------------------------
JPA與hibernate的關係

JPA規範本質上就是一種ORM規範，注意不是ORM框架——因爲JPA並未提供ORM實現，它只是制訂了一些規範，提供了一些編程的API接口，
但具體實現則由服務廠商來提供實現。
JPA和Hibernate的關係就像JDBC和JDBC驅動的關係，JPA是規範，Hibernate除了作爲ORM框架之外，它也是一種JPA實現。JPA怎麼取代
Hibernate呢？JDBC規範可以驅動底層數據庫嗎？答案是否定的，也就是說，如果使用JPA規範進行數據庫操作，底層需要hibernate作爲
其實現類完成數據持久化工作。
------------------------------------------------------------------------------------------------------------------------
案例（一對多）
常用註解說明
@Entity ：指定當前類是持久化實體類，不能省略
@Table
作用：指定實體類和表之間的對應關係，可以省略
默認：表名=類名(省略後)
屬性： name：指定數據庫表的名稱
@Id ：指定當前字段是主鍵。不能省略
@GeneratedValue
作用：指定主鍵的生成方式。。
屬性： strategy ：指定主鍵生成策略。
@Column
作用：指定實體類屬性和數據庫表之間的對應關係
屬性：
name：指定數據庫表的列名稱。
unique：是否唯一
nullable：是否可以爲空
inserttable：是否可以插入
updateable：是否可以更新
columnDefinition: 定義建表時創建此列的DDL
secondaryTable: 從表名。如果此列不建在主表上（默認建在主表），該屬性定義該列所在從表的名字搭建開發環境[重點]
@OneToMany：映射一對多
mapperdBy：指定對方關聯屬性，表示當前類不管理關聯關係，相當於inverse=false
fetch：是否使用懶加載
@ManyToOne：映射多對一
@JoinColumn：映射外鍵
@ManyToMany：映射多對多
mappedBy=“對方的關聯屬性”：相當於inverse=true，便是當前方不管理關聯關係
在管理關聯關係的一方配置關係表@JoinTable
@JoinTable
name：關係表名
joinColumns：當前表在中間表的外鍵
inverseJoinColumns：對方表在中間表的外鍵